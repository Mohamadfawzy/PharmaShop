    /*
    public async Task<AppResponse<LoginResponseDto>> LoginAsync(LoginRequestDto dto, CancellationToken ct)
    {
        // Normalize
        var identifier = dto.Identifier?.Trim() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(identifier))
        {
            return AppResponse<LoginResponseDto>.ValidationErrors(
                new Dictionary<string, string[]>
                {
                    ["Identifier"] = new[] { "Identifier is required" }
                },
                detail: "Validation failed"
            );
        }

        // 1) Find user by Email OR Username (بدون user enumeration في الرسالة النهائية)
        ApplicationUser? user = null;

        if (identifier.Contains('@'))
        {
            var normalizedEmail = identifier.ToLowerInvariant();
            user = await _userManager.FindByEmailAsync(normalizedEmail);
        }
        else
        {
            user = await _userManager.FindByNameAsync(identifier);
        }

        // رسالة موحدة لتفادي كشف هل المستخدم موجود أم لا (Security best practice)
        static AppResponse<LoginResponseDto> InvalidCredentials() =>
            AppResponse<LoginResponseDto>.Unauthorized("Invalid credentials");

        if (user is null)
            return InvalidCredentials();

        // 2) Business flags (مثال: IsActive)
        // IMPORTANT: لو عندك IsActive في ApplicationUser
        if (user is { IsActive: false })
            return AppResponse<LoginResponseDto>.Forbidden("User account is disabled");

        // 3) Email confirmation policy
        // بما أنك فعلت options.SignIn.RequireConfirmedEmail = true
        // ممكن تعتمد على SignInManager ويفشل تلقائياً، لكن الأفضل رسالة واضحة:
        if (!user.EmailConfirmed)
            return AppResponse<LoginResponseDto>.Forbidden("Email is not confirmed");

        // 4) Lockout check (Real-world)
        if (await _userManager.IsLockedOutAsync(user))
            return AppResponse<LoginResponseDto>.Forbidden("Account is locked. Try again later.");

        // 5) Verify password (مع دعم lockoutOnFailure)
        // SignInManager أفضل من CheckPasswordAsync لأنه يطبّق lockout counters.
        var signInResult = await _signInManager.CheckPasswordSignInAsync(
            user,
            dto.Password,
            lockoutOnFailure: true
        );

        if (signInResult.IsLockedOut)
            return AppResponse<LoginResponseDto>.Forbidden("Account is locked. Try again later.");

        if (!signInResult.Succeeded)
            return InvalidCredentials();

        // 6) (اختياري) Update last login (لو عندك أعمدة أو جدول Audit)
        // Future: سجل LoginEvent + IP + UserAgent + DeviceId

        // 7) Issue JWT
        // pharmacy_id: الآن ثابت 1، لاحقاً تُستخرج من Admin/Customer profile أو Tenant middleware
        var accessToken = await _jwtTokenService.CreateAccessTokenAsync(user, pharmacyId: 1);

        // JWT expiry (نحسبها من config بدل ما نفك JWT)
        var minutes = int.Parse(configuration.GetSection("Jwt")["AccessTokenMinutes"]!);
        var expiresAt = DateTime.UtcNow.AddMinutes(minutes);

        // 8) Return
        return AppResponse<LoginResponseDto>.Ok(new LoginResponseDto
        {
            UserId = user.Id,
            AccessToken = accessToken,
            ExpiresAtUtc = expiresAt
        }, "Login successful");
    }
     */